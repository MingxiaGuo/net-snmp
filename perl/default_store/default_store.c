/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.28 from the
 * contents of default_store.xs. Do not edit this file, edit default_store.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "default_store.xs"
#if defined(_WIN32) && !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x501
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/library/default_store.h>


/* autogenerated by "gen" from const-c.inc */

#define PERL_constant_NOTFOUND	1
#define PERL_constant_NOTDEF	2
#define PERL_constant_ISIV	3
#define PERL_constant_ISNO	4
#define PERL_constant_ISNV	5
#define PERL_constant_ISPV	6
#define PERL_constant_ISPVN	7
#define PERL_constant_ISSV	8
#define PERL_constant_ISUNDEF	9
#define PERL_constant_ISUV	10
#define PERL_constant_ISYES	11

#ifndef NVTYPE
typedef double NV; /* 5.6 and later define NVTYPE, and typedef NV to it.  */
#endif
#ifndef aTHX_
#define aTHX_ /* 5.6 or later define this for threading support.  */
#endif
#ifndef pTHX_
#define pTHX_ /* 5.6 or later define this for threading support.  */
#endif

static int
constant_22 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPTYPE NETSNMP_DS_LIB_CONTEXT NETSNMP_DS_LIB_MIBDIRS
     NETSNMP_DS_LIB_SECNAME */
  /* Offset 16 gives the best switch position.  */
  switch (name[16]) {
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_SECNAME", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_SECNAME
      *iv_return = NETSNMP_DS_LIB_SECNAME;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_MIBDIRS", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_MIBDIRS
      *iv_return = NETSNMP_DS_LIB_MIBDIRS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'O':
    if (memEQ(name, "NETSNMP_DS_LIB_CONTEXT", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_CONTEXT
      *iv_return = NETSNMP_DS_LIB_CONTEXT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_APPTYPE", 22)) {
    /*                               ^            */
#ifdef NETSNMP_DS_LIB_APPTYPE
      *iv_return = NETSNMP_DS_LIB_APPTYPE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_23 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPTYPES NETSNMP_DS_LIB_SECLEVEL NETSNMP_DS_LIB_SECMODEL */
  /* Offset 18 gives the best switch position.  */
  switch (name[18]) {
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_SECLEVEL", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_SECLEVEL
      *iv_return = NETSNMP_DS_LIB_SECLEVEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_SECMODEL", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_SECMODEL
      *iv_return = NETSNMP_DS_LIB_SECMODEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'T':
    if (memEQ(name, "NETSNMP_DS_LIB_APPTYPES", 23)) {
    /*                                 ^           */
#ifdef NETSNMP_DS_LIB_APPTYPES
      *iv_return = NETSNMP_DS_LIB_APPTYPES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_24 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_16BIT_IDS NETSNMP_DS_LIB_COMMUNITY NETSNMP_DS_LIB_OIDPREFIX
     NETSNMP_DS_LIB_OIDSUFFIX */
  /* Offset 18 gives the best switch position.  */
  switch (name[18]) {
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_16BIT_IDS", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_16BIT_IDS
      *iv_return = NETSNMP_DS_LIB_16BIT_IDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_COMMUNITY", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_COMMUNITY
      *iv_return = NETSNMP_DS_LIB_COMMUNITY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_OIDPREFIX", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_OIDPREFIX
      *iv_return = NETSNMP_DS_LIB_OIDPREFIX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_OIDSUFFIX", 24)) {
    /*                                 ^            */
#ifdef NETSNMP_DS_LIB_OIDSUFFIX
      *iv_return = NETSNMP_DS_LIB_OIDSUFFIX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_25 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_APPLICATION_ID NETSNMP_DS_LIB_KSM_KEYTAB
     NETSNMP_DS_LIB_MIB_ERRORS NETSNMP_DS_LIB_PASSPHRASE
     NETSNMP_DS_SNMP_VERSION_1 NETSNMP_DS_SNMP_VERSION_3 */
  /* Offset 24 gives the best switch position.  */
  switch (name[24]) {
  case '1':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_", 24)) {
    /*                                       1      */
#ifdef NETSNMP_DS_SNMP_VERSION_1
      *iv_return = NETSNMP_DS_SNMP_VERSION_1;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case '3':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_", 24)) {
    /*                                       3      */
#ifdef NETSNMP_DS_SNMP_VERSION_3
      *iv_return = NETSNMP_DS_SNMP_VERSION_3;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_KSM_KEYTA", 24)) {
    /*                                       B      */
#ifdef NETSNMP_DS_LIB_KSM_KEYTAB
      *iv_return = NETSNMP_DS_LIB_KSM_KEYTAB;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'D':
    if (memEQ(name, "NETSNMP_DS_APPLICATION_I", 24)) {
    /*                                       D      */
#ifdef NETSNMP_DS_APPLICATION_ID
      *iv_return = NETSNMP_DS_APPLICATION_ID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_PASSPHRAS", 24)) {
    /*                                       E      */
#ifdef NETSNMP_DS_LIB_PASSPHRASE
      *iv_return = NETSNMP_DS_LIB_PASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_ERROR", 24)) {
    /*                                       S      */
#ifdef NETSNMP_DS_LIB_MIB_ERRORS
      *iv_return = NETSNMP_DS_LIB_MIB_ERRORS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_26 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_CLIENT_ADDR NETSNMP_DS_LIB_DUMP_PACKET
     NETSNMP_DS_LIB_MIB_REPLACE NETSNMP_DS_LIB_QUICK_PRINT
     NETSNMP_DS_LIB_SNMPVERSION NETSNMP_DS_SNMP_VERSION_2c */
  /* Offset 22 gives the best switch position.  */
  switch (name[22]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENT_ADDR", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_CLIENT_ADDR
      *iv_return = NETSNMP_DS_LIB_CLIENT_ADDR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_DUMP_PACKET", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_DUMP_PACKET
      *iv_return = NETSNMP_DS_LIB_DUMP_PACKET;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_REPLACE", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_MIB_REPLACE
      *iv_return = NETSNMP_DS_LIB_MIB_REPLACE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_SNMP_VERSION_2c", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_SNMP_VERSION_2c
      *iv_return = NETSNMP_DS_SNMP_VERSION_2c;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'R':
    if (memEQ(name, "NETSNMP_DS_LIB_QUICK_PRINT", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_QUICK_PRINT
      *iv_return = NETSNMP_DS_LIB_QUICK_PRINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_SNMPVERSION", 26)) {
    /*                                     ^          */
#ifdef NETSNMP_DS_LIB_SNMPVERSION
      *iv_return = NETSNMP_DS_LIB_SNMPVERSION;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_27 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DEFAULT_PORT NETSNMP_DS_LIB_MIB_WARNINGS
     NETSNMP_DS_LIB_QUICKE_PRINT NETSNMP_DS_LIB_REGEX_ACCESS */
  /* Offset 17 gives the best switch position.  */
  switch (name[17]) {
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_WARNINGS", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_MIB_WARNINGS
      *iv_return = NETSNMP_DS_LIB_MIB_WARNINGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'F':
    if (memEQ(name, "NETSNMP_DS_LIB_DEFAULT_PORT", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_DEFAULT_PORT
      *iv_return = NETSNMP_DS_LIB_DEFAULT_PORT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_REGEX_ACCESS", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_REGEX_ACCESS
      *iv_return = NETSNMP_DS_LIB_REGEX_ACCESS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_QUICKE_PRINT", 27)) {
    /*                                ^                */
#ifdef NETSNMP_DS_LIB_QUICKE_PRINT
      *iv_return = NETSNMP_DS_LIB_QUICKE_PRINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_28 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHMASTERKEY NETSNMP_DS_LIB_CLIENTRECVBUF
     NETSNMP_DS_LIB_CLIENTSENDBUF NETSNMP_DS_LIB_ESCAPE_QUOTES
     NETSNMP_DS_LIB_LOG_TIMESTAMP NETSNMP_DS_LIB_PRIVMASTERKEY
     NETSNMP_DS_LIB_RANDOM_ACCESS NETSNMP_DS_LIB_SERVERRECVBUF
     NETSNMP_DS_LIB_SERVERSENDBUF */
  /* Offset 15 gives the best switch position.  */
  switch (name[15]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHMASTERKEY", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_AUTHMASTERKEY
      *iv_return = NETSNMP_DS_LIB_AUTHMASTERKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENTRECVBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_CLIENTRECVBUF
      *iv_return = NETSNMP_DS_LIB_CLIENTRECVBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENTSENDBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_CLIENTSENDBUF
      *iv_return = NETSNMP_DS_LIB_CLIENTSENDBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_ESCAPE_QUOTES", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_ESCAPE_QUOTES
      *iv_return = NETSNMP_DS_LIB_ESCAPE_QUOTES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_LOG_TIMESTAMP", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_LOG_TIMESTAMP
      *iv_return = NETSNMP_DS_LIB_LOG_TIMESTAMP;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVMASTERKEY", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_PRIVMASTERKEY
      *iv_return = NETSNMP_DS_LIB_PRIVMASTERKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'R':
    if (memEQ(name, "NETSNMP_DS_LIB_RANDOM_ACCESS", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_RANDOM_ACCESS
      *iv_return = NETSNMP_DS_LIB_RANDOM_ACCESS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_SERVERRECVBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_SERVERRECVBUF
      *iv_return = NETSNMP_DS_LIB_SERVERRECVBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_SERVERSENDBUF", 28)) {
    /*                              ^                   */
#ifdef NETSNMP_DS_LIB_SERVERSENDBUF
      *iv_return = NETSNMP_DS_LIB_SERVERSENDBUF;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_29 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHPASSPHRASE NETSNMP_DS_LIB_EXTENDED_INDEX
     NETSNMP_DS_LIB_OPTIONALCONFIG NETSNMP_DS_LIB_PERSISTENT_DIR
     NETSNMP_DS_LIB_PRINT_FULL_OID NETSNMP_DS_LIB_PRINT_HEX_TEXT
     NETSNMP_DS_LIB_PRIVPASSPHRASE NETSNMP_DS_LIB_REVERSE_ENCODE
     NETSNMP_DS_LIB_SBSM_LOCAL_PWD */
  /* Offset 23 gives the best switch position.  */
  switch (name[23]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_SBSM_LOCAL_PWD", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_SBSM_LOCAL_PWD
      *iv_return = NETSNMP_DS_LIB_SBSM_LOCAL_PWD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_OPTIONALCONFIG", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_OPTIONALCONFIG
      *iv_return = NETSNMP_DS_LIB_OPTIONALCONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_REVERSE_ENCODE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_REVERSE_ENCODE
      *iv_return = NETSNMP_DS_LIB_REVERSE_ENCODE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_FULL_OID", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRINT_FULL_OID
      *iv_return = NETSNMP_DS_LIB_PRINT_FULL_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_PERSISTENT_DIR", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PERSISTENT_DIR
      *iv_return = NETSNMP_DS_LIB_PERSISTENT_DIR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHPASSPHRASE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_AUTHPASSPHRASE
      *iv_return = NETSNMP_DS_LIB_AUTHPASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVPASSPHRASE", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRIVPASSPHRASE
      *iv_return = NETSNMP_DS_LIB_PRIVPASSPHRASE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'X':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_HEX_TEXT", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_PRINT_HEX_TEXT
      *iv_return = NETSNMP_DS_LIB_PRINT_HEX_TEXT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case '_':
    if (memEQ(name, "NETSNMP_DS_LIB_EXTENDED_INDEX", 29)) {
    /*                                      ^            */
#ifdef NETSNMP_DS_LIB_EXTENDED_INDEX
      *iv_return = NETSNMP_DS_LIB_EXTENDED_INDEX;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_30 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_APPEND_LOGFILES NETSNMP_DS_LIB_MIB_PARSE_LABEL
     NETSNMP_DS_LIB_NO_DISPLAY_HINT NETSNMP_DS_LIB_SAVE_MIB_DESCRS */
  /* Offset 27 gives the best switch position.  */
  switch (name[27]) {
  case 'B':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_PARSE_LABEL", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_MIB_PARSE_LABEL
      *iv_return = NETSNMP_DS_LIB_MIB_PARSE_LABEL;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_SAVE_MIB_DESCRS", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_SAVE_MIB_DESCRS
      *iv_return = NETSNMP_DS_LIB_SAVE_MIB_DESCRS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_NO_DISPLAY_HINT", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_NO_DISPLAY_HINT
      *iv_return = NETSNMP_DS_LIB_NO_DISPLAY_HINT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_APPEND_LOGFILES", 30)) {
    /*                                          ^         */
#ifdef NETSNMP_DS_LIB_APPEND_LOGFILES
      *iv_return = NETSNMP_DS_LIB_APPEND_LOGFILES;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_31 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_AUTHLOCALIZEDKEY NETSNMP_DS_LIB_DONT_CHECK_RANGE
     NETSNMP_DS_LIB_DONT_PRINT_UNITS NETSNMP_DS_LIB_HAVE_READ_CONFIG
     NETSNMP_DS_LIB_KSM_SERVICE_NAME NETSNMP_DS_LIB_MIB_COMMENT_TERM
     NETSNMP_DS_LIB_PRINT_BARE_VALUE NETSNMP_DS_LIB_PRIVLOCALIZEDKEY */
  /* Offset 28 gives the best switch position.  */
  switch (name[28]) {
  case 'A':
    if (memEQ(name, "NETSNMP_DS_LIB_KSM_SERVICE_NAME", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_KSM_SERVICE_NAME
      *iv_return = NETSNMP_DS_LIB_KSM_SERVICE_NAME;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_MIB_COMMENT_TERM", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_MIB_COMMENT_TERM
      *iv_return = NETSNMP_DS_LIB_MIB_COMMENT_TERM;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'F':
    if (memEQ(name, "NETSNMP_DS_LIB_HAVE_READ_CONFIG", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_HAVE_READ_CONFIG
      *iv_return = NETSNMP_DS_LIB_HAVE_READ_CONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_PRINT_UNITS", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_DONT_PRINT_UNITS
      *iv_return = NETSNMP_DS_LIB_DONT_PRINT_UNITS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'K':
    if (memEQ(name, "NETSNMP_DS_LIB_AUTHLOCALIZEDKEY", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_AUTHLOCALIZEDKEY
      *iv_return = NETSNMP_DS_LIB_AUTHLOCALIZEDKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRIVLOCALIZEDKEY", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_PRIVLOCALIZEDKEY
      *iv_return = NETSNMP_DS_LIB_PRIVLOCALIZEDKEY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_BARE_VALUE", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_PRINT_BARE_VALUE
      *iv_return = NETSNMP_DS_LIB_PRINT_BARE_VALUE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_CHECK_RANGE", 31)) {
    /*                                           ^         */
#ifdef NETSNMP_DS_LIB_DONT_CHECK_RANGE
      *iv_return = NETSNMP_DS_LIB_DONT_CHECK_RANGE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_32 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT NETSNMP_DS_LIB_CONFIGURATION_DIR
     NETSNMP_DS_LIB_DONT_READ_CONFIGS NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
     NETSNMP_DS_LIB_NO_TOKEN_WARNINGS NETSNMP_DS_LIB_NUMERIC_TIMETICKS
     NETSNMP_DS_LIB_OID_OUTPUT_FORMAT NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
     NETSNMP_DS_LIB_TEMP_FILE_PATTERN */
  /* Offset 29 gives the best switch position.  */
  switch (name[29]) {
  case 'C':
    if (memEQ(name, "NETSNMP_DS_LIB_NUMERIC_TIMETICKS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_NUMERIC_TIMETICKS
      *iv_return = NETSNMP_DS_LIB_NUMERIC_TIMETICKS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_CONFIGURATION_DIR", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_CONFIGURATION_DIR
      *iv_return = NETSNMP_DS_LIB_CONFIGURATION_DIR;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_TEMP_FILE_PATTERN", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_TEMP_FILE_PATTERN
      *iv_return = NETSNMP_DS_LIB_TEMP_FILE_PATTERN;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
      *iv_return = NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'I':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_READ_CONFIGS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_DONT_READ_CONFIGS
      *iv_return = NETSNMP_DS_LIB_DONT_READ_CONFIGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_OID_OUTPUT_FORMAT", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_OID_OUTPUT_FORMAT
      *iv_return = NETSNMP_DS_LIB_OID_OUTPUT_FORMAT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_NO_TOKEN_WARNINGS", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_NO_TOKEN_WARNINGS
      *iv_return = NETSNMP_DS_LIB_NO_TOKEN_WARNINGS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
      *iv_return = NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'P':
    if (memEQ(name, "NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT", 32)) {
    /*                                            ^         */
#ifdef NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT
      *iv_return = NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_33 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_ALARM_DONT_USE_SIG NETSNMP_DS_LIB_DONT_PERSIST_STATE
     NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
     NETSNMP_DS_LIB_READ_UCD_STYLE_OID */
  /* Offset 32 gives the best switch position.  */
  switch (name[32]) {
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_READ_UCD_STYLE_OI", 32)) {
    /*                                               D      */
#ifdef NETSNMP_DS_LIB_READ_UCD_STYLE_OID
      *iv_return = NETSNMP_DS_LIB_READ_UCD_STYLE_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_PERSIST_STAT", 32)) {
    /*                                               E      */
#ifdef NETSNMP_DS_LIB_DONT_PERSIST_STATE
      *iv_return = NETSNMP_DS_LIB_DONT_PERSIST_STATE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_ALARM_DONT_USE_SI", 32)) {
    /*                                               G      */
#ifdef NETSNMP_DS_LIB_ALARM_DONT_USE_SIG
      *iv_return = NETSNMP_DS_LIB_ALARM_DONT_USE_SIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_NUMERIC_ENU", 32)) {
    /*                                               M      */
#ifdef NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM
      *iv_return = NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'S':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_NUMERIC_OID", 32)) {
    /*                                               S      */
#ifdef NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
      *iv_return = NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_34 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
     NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID */
  /* Offset 28 gives the best switch position.  */
  switch (name[28]) {
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD
      *iv_return = NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'L':
    if (memEQ(name, "NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID
      *iv_return = NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'M':
    if (memEQ(name, "NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY
      *iv_return = NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'N':
    if (memEQ(name, "NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS", 34)) {
    /*                                           ^            */
#ifdef NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
      *iv_return = NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant_38 (pTHX_ const char *name, IV *iv_return) {
  /* When generated this function returned values for the list of names given
     here.  However, subsequent manual editing may have added or removed some.
     NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
     NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
     NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG */
  /* Offset 37 gives the best switch position.  */
  switch (name[37]) {
  case 'D':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOA", 37)) {
    /*                                                    D      */
#ifdef NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
      *iv_return = NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'E':
    if (memEQ(name, "NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAV", 37)) {
    /*                                                    E      */
#ifdef NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
      *iv_return = NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 'G':
    if (memEQ(name, "NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFI", 37)) {
    /*                                                    G      */
#ifdef NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG
      *iv_return = NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  }
  return PERL_constant_NOTFOUND;
}

static int
constant (pTHX_ const char *name, STRLEN len, IV *iv_return) {
  /* Initially switch on the length of the name.  */
  /* When generated this function returned values for the list of names given
     in this section of perl code.  Rather than manually editing these functions
     to add or remove constants, which would result in this comment and section
     of code becoming inaccurate, we recommend that you edit this section of
     code, and use it to regenerate a new set of constant functions which you
     then use to replace the originals.

     Regenerate these constant functions by feeding this entire source file to
     perl -x

#!/usr/bin/perl -w
use ExtUtils::Constant qw (constant_types C_constant XS_constant);

my $types = {map {($_, 1)} qw(IV)};
my @names = (qw(NETSNMP_DS_APPLICATION_ID NETSNMP_DS_LIBRARY_ID
	       NETSNMP_DS_LIB_16BIT_IDS NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT
	       NETSNMP_DS_LIB_ALARM_DONT_USE_SIG NETSNMP_DS_LIB_APPEND_LOGFILES
	       NETSNMP_DS_LIB_APPTYPE NETSNMP_DS_LIB_APPTYPES
	       NETSNMP_DS_LIB_AUTHLOCALIZEDKEY NETSNMP_DS_LIB_AUTHMASTERKEY
	       NETSNMP_DS_LIB_AUTHPASSPHRASE NETSNMP_DS_LIB_CLIENTRECVBUF
	       NETSNMP_DS_LIB_CLIENTSENDBUF NETSNMP_DS_LIB_CLIENT_ADDR
	       NETSNMP_DS_LIB_COMMUNITY NETSNMP_DS_LIB_CONFIGURATION_DIR
	       NETSNMP_DS_LIB_CONTEXT NETSNMP_DS_LIB_DEFAULT_PORT
	       NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD
	       NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD
	       NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE
	       NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
	       NETSNMP_DS_LIB_DONT_CHECK_RANGE
	       NETSNMP_DS_LIB_DONT_PERSIST_STATE
	       NETSNMP_DS_LIB_DONT_PRINT_UNITS NETSNMP_DS_LIB_DONT_READ_CONFIGS
	       NETSNMP_DS_LIB_DUMP_PACKET NETSNMP_DS_LIB_ESCAPE_QUOTES
	       NETSNMP_DS_LIB_EXTENDED_INDEX NETSNMP_DS_LIB_HAVE_READ_CONFIG
	       NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG
	       NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH
	       NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY NETSNMP_DS_LIB_KSM_KEYTAB
	       NETSNMP_DS_LIB_KSM_SERVICE_NAME NETSNMP_DS_LIB_LOG_TIMESTAMP
	       NETSNMP_DS_LIB_MIBDIRS NETSNMP_DS_LIB_MIB_COMMENT_TERM
	       NETSNMP_DS_LIB_MIB_ERRORS NETSNMP_DS_LIB_MIB_PARSE_LABEL
	       NETSNMP_DS_LIB_MIB_REPLACE NETSNMP_DS_LIB_MIB_WARNINGS
	       NETSNMP_DS_LIB_NO_DISPLAY_HINT NETSNMP_DS_LIB_NO_TOKEN_WARNINGS
	       NETSNMP_DS_LIB_NUMERIC_TIMETICKS NETSNMP_DS_LIB_OIDPREFIX
	       NETSNMP_DS_LIB_OIDSUFFIX NETSNMP_DS_LIB_OID_OUTPUT_FORMAT
	       NETSNMP_DS_LIB_OPTIONALCONFIG NETSNMP_DS_LIB_PASSPHRASE
	       NETSNMP_DS_LIB_PERSISTENT_DIR NETSNMP_DS_LIB_PRINT_BARE_VALUE
	       NETSNMP_DS_LIB_PRINT_FULL_OID NETSNMP_DS_LIB_PRINT_HEX_TEXT
	       NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM
	       NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
	       NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
	       NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID
	       NETSNMP_DS_LIB_PRIVLOCALIZEDKEY NETSNMP_DS_LIB_PRIVMASTERKEY
	       NETSNMP_DS_LIB_PRIVPASSPHRASE NETSNMP_DS_LIB_QUICKE_PRINT
	       NETSNMP_DS_LIB_QUICK_PRINT NETSNMP_DS_LIB_RANDOM_ACCESS
	       NETSNMP_DS_LIB_READ_UCD_STYLE_OID NETSNMP_DS_LIB_REGEX_ACCESS
	       NETSNMP_DS_LIB_REVERSE_ENCODE NETSNMP_DS_LIB_SAVE_MIB_DESCRS
	       NETSNMP_DS_LIB_SBSM_LOCAL_PWD NETSNMP_DS_LIB_SECLEVEL
	       NETSNMP_DS_LIB_SECMODEL NETSNMP_DS_LIB_SECNAME
	       NETSNMP_DS_LIB_SERVERRECVBUF NETSNMP_DS_LIB_SERVERSENDBUF
	       NETSNMP_DS_LIB_SNMPVERSION NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT
	       NETSNMP_DS_LIB_TEMP_FILE_PATTERN NETSNMP_DS_MAX_IDS
	       NETSNMP_DS_MAX_SUBIDS NETSNMP_DS_SNMP_VERSION_1
	       NETSNMP_DS_SNMP_VERSION_2c NETSNMP_DS_SNMP_VERSION_3
	       NETSNMP_DS_TOKEN_ID));

print constant_types(); # macro defs
foreach (C_constant ("NetSNMP::default_store", 'constant', 'IV', $types, undef, 3, @names) ) {
    print $_, "\n"; # C constant subs
}
print "#### XS Section:\n";
print XS_constant ("NetSNMP::default_store", $types);
__END__
   */

  switch (len) {
  case 18:
    if (memEQ(name, "NETSNMP_DS_MAX_IDS", 18)) {
#ifdef NETSNMP_DS_MAX_IDS
      *iv_return = NETSNMP_DS_MAX_IDS;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 19:
    if (memEQ(name, "NETSNMP_DS_TOKEN_ID", 19)) {
#ifdef NETSNMP_DS_TOKEN_ID
      *iv_return = NETSNMP_DS_TOKEN_ID;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 21:
    /* Names all of length 21.  */
    /* NETSNMP_DS_LIBRARY_ID NETSNMP_DS_MAX_SUBIDS */
    /* Offset 11 gives the best switch position.  */
    switch (name[11]) {
    case 'L':
      if (memEQ(name, "NETSNMP_DS_LIBRARY_ID", 21)) {
      /*                          ^                */
#ifdef NETSNMP_DS_LIBRARY_ID
        *iv_return = NETSNMP_DS_LIBRARY_ID;
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    case 'M':
      if (memEQ(name, "NETSNMP_DS_MAX_SUBIDS", 21)) {
      /*                          ^                */
#ifdef NETSNMP_DS_MAX_SUBIDS
        *iv_return = NETSNMP_DS_MAX_SUBIDS;
        return PERL_constant_ISIV;
#else
        return PERL_constant_NOTDEF;
#endif
      }
      break;
    }
    break;
  case 22:
    return constant_22 (aTHX_ name, iv_return);
    break;
  case 23:
    return constant_23 (aTHX_ name, iv_return);
    break;
  case 24:
    return constant_24 (aTHX_ name, iv_return);
    break;
  case 25:
    return constant_25 (aTHX_ name, iv_return);
    break;
  case 26:
    return constant_26 (aTHX_ name, iv_return);
    break;
  case 27:
    return constant_27 (aTHX_ name, iv_return);
    break;
  case 28:
    return constant_28 (aTHX_ name, iv_return);
    break;
  case 29:
    return constant_29 (aTHX_ name, iv_return);
    break;
  case 30:
    return constant_30 (aTHX_ name, iv_return);
    break;
  case 31:
    return constant_31 (aTHX_ name, iv_return);
    break;
  case 32:
    return constant_32 (aTHX_ name, iv_return);
    break;
  case 33:
    return constant_33 (aTHX_ name, iv_return);
    break;
  case 34:
    return constant_34 (aTHX_ name, iv_return);
    break;
  case 35:
    if (memEQ(name, "NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT", 35)) {
#ifdef NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT
      *iv_return = NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;
  case 36:
    if (memEQ(name, "NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT", 36)) {
#ifdef NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT
      *iv_return = NETSNMP_DS_LIB_CLIENT_ADDR_USES_PORT;
      return PERL_constant_ISIV;
#else
      return PERL_constant_NOTDEF;
#endif
    }
    break;

  case 38:
    return constant_38 (aTHX_ name, iv_return);
    break;
  }
  return PERL_constant_NOTFOUND;
}

/* autogenerated by "gen" from const-xs.inc */

#line 1271 "default_store.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 1415 "default_store.c"

XS_EUPXS(XS_NetSNMP__default_store_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1266 "default_store.xs"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv = 0;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 1437 "default_store.c"
	SV *	sv = ST(0)
;
	const char *	s = SvPV(sv, len);
#line 1280 "default_store.xs"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv = sv_2mortal(newSVpvf("%s is not a valid NetSNMP::default_store macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined NetSNMP::default_store macro %s, used", s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing NetSNMP::default_store macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 1513 "default_store.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_boolean)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "storeid, which");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_get_boolean(storeid, which);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_int)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "storeid, which");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_get_int(storeid, which);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "storeid, which");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	char *	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_get_string(storeid, which);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_void); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_get_void)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "storeid, which");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	void *	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_get_void(storeid, which);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_register_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_register_config)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "type, ftype, token, storeid, which");
    {
	unsigned char	type = (unsigned char)SvUV(ST(0))
;
	const char *	ftype = (const char *)SvPV_nolen(ST(1))
;
	const char *	token = (const char *)SvPV_nolen(ST(2))
;
	int	storeid = (int)SvIV(ST(3))
;
	int	which = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_register_config(type, ftype, token, storeid, which);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_register_premib); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_register_premib)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "type, ftype, token, storeid, which");
    {
	unsigned char	type = (unsigned char)SvUV(ST(0))
;
	const char *	ftype = (const char *)SvPV_nolen(ST(1))
;
	const char *	token = (const char *)SvPV_nolen(ST(2))
;
	int	storeid = (int)SvIV(ST(3))
;
	int	which = (int)SvIV(ST(4))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_register_premib(type, ftype, token, storeid, which);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_boolean)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "storeid, which, value");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	int	value = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_set_boolean(storeid, which, value);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_int)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "storeid, which, value");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	int	value = (int)SvIV(ST(2))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_set_int(storeid, which, value);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_string)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "storeid, which, value");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	const char *	value = (const char *)SvPV_nolen(ST(2))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_set_string(storeid, which, value);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_void); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_set_void)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "storeid, which, value");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	void *	value = INT2PTR(void *,SvIV(ST(2)))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_set_void(storeid, which, value);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_shutdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_shutdown)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {

	netsnmp_ds_shutdown();
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_toggle_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_NetSNMP__default_store_netsnmp_ds_toggle_boolean)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "storeid, which");
    {
	int	storeid = (int)SvIV(ST(0))
;
	int	which = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	RETVAL = netsnmp_ds_toggle_boolean(storeid, which);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_NetSNMP__default_store); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_NetSNMP__default_store)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("NetSNMP::default_store::constant", XS_NetSNMP__default_store_constant, file, "$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_get_boolean", XS_NetSNMP__default_store_netsnmp_ds_get_boolean, file, "$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_get_int", XS_NetSNMP__default_store_netsnmp_ds_get_int, file, "$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_get_string", XS_NetSNMP__default_store_netsnmp_ds_get_string, file, "$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_get_void", XS_NetSNMP__default_store_netsnmp_ds_get_void, file, "$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_register_config", XS_NetSNMP__default_store_netsnmp_ds_register_config, file, "$$$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_register_premib", XS_NetSNMP__default_store_netsnmp_ds_register_premib, file, "$$$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_set_boolean", XS_NetSNMP__default_store_netsnmp_ds_set_boolean, file, "$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_set_int", XS_NetSNMP__default_store_netsnmp_ds_set_int, file, "$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_set_string", XS_NetSNMP__default_store_netsnmp_ds_set_string, file, "$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_set_void", XS_NetSNMP__default_store_netsnmp_ds_set_void, file, "$$$");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_shutdown", XS_NetSNMP__default_store_netsnmp_ds_shutdown, file, "");
        (void)newXSproto_portable("NetSNMP::default_store::netsnmp_ds_toggle_boolean", XS_NetSNMP__default_store_netsnmp_ds_toggle_boolean, file, "$$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

